{
  {
    "keys": [
      "|"
    ], 
    "doc": "<h1>Core <code>|</code> \"bar\"</h1>\n<p>Core hoons are flow hoons. The compiler essentially pins a Nock\nformula, or battery of formulas, to the subject.</p>\n<p>All <code>|</code> hoons are macros around <code>%core</code>. (See the <code>%core</code>\nsection in <a href=\"../../basic#-core-p-type-q-map-term-type\"><code>type</code></a> above.)\n<code>%core</code> uses the subject as the payload of a battery, whose arms are\ncompiled with the core itself as the subject.</p>\n<p>Four of these hoons (<code>|=</code>, <code>|.</code>, <code>|-</code>, and <code>|*</code>) produce a\ncore with a single arm, named <code>$</code>. We can recompute this arm \nwith changes, useful for recursion among other things:</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../cen/hep\">\"cenhep\"</a>), accepting \na <em>jogging</em> body containing a list of changes to the subject.</p>\n</blockquote>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
  }, 
  {
    "keys": [
      "$"
    ], 
    "doc": "<h1>Mold <code>$</code> \"buc\"</h1>\n<p>A <em>mold</em> is a <code>gate</code> (function) that helps us build simple and\nrigorous data structures.  (In fact, since \"mold\" sounds nasty,\nwe often call molds and mold builders \"structures.\")</p>\n<h2>Overview</h2>\n<p>A correct mold is a <em>normalizer</em>: an idempotent function across\nall nouns.  If the sample of a gate has type <code>%noun</code>, and its\nbody obeys the constraint that for any x, <code>=((mold x) (mold (mold\nx)))</code>, it's a normalizer and can be used as a mold.</p>\n<p>(Hoon is not dependently typed and so can't check idempotence\nstatically, so we can't actually tell if a mold matches this\ndefinition perfectly.  This is not actually a problem.)</p>\n<p>Runes in the <code>$</code> family are macros designed for making molds.\nBut any hoon may produce a mold. (This is why <code>model</code> is a\nsynonym for <code>hoon</code>).</p>\n<p>Many macros <em>bunt</em> a mold, producing <code>^~(=&gt;(mold $))</code>.  This\nproduces a constant default value.  The formal range of a mold\n(the type of its bunt) is called its <em>icon</em>.</p>\n<p>Molds have two uses: defining simple and rigorous structures, and\nvalidating untrusted input data.  Validation, though very\nimportant, is a rare use case.  Except for direct raw input,\nit's generally a faux pas to rectify nouns at runtime -- or even\nin userspace.</p>\n<p>As a structure definition, a mold has three common uses.  One,\nwe bunt it for a default value (such as the sample in a gate).\nTwo, the product of some computation is cast to its icon, both\nchecking the type and regularizing it.  Three, it's used as a\nbuilding block in other molds.</p>\n<p>In any case, since molds are just functions, we can use\nfunctional programming to assemble interesting molds.  For\ninstance, <code>(map foo bar)</code> is a table from mold <code>foo</code> to mold\n<code>bar</code>.  <code>map</code> is not a mold; it's a function that makes a mold.\nMolds and mold builders are generally described together.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
  }
  }
